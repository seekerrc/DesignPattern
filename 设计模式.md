# 设计模式

## 设计模式七大原则

设计模式原则其实就是程序员在编程时应当遵守的原则，也是各种设计模式的基础

### 单一职责原则

==一个类应该只负责一项职责==

如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误

所以需要将类 A 的粒度分解为 A1，A2



#### 违反原则

```java
public class SingleResponsibility1 {
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        Vehicle vehicle = new Vehicle();
        vehicle.run("摩托车");
        vehicle.run("汽车");
        vehicle.run("飞机");
    }
}

class Vehicle {
    public void run(String vehicle) {
        System.out.println(vehicle + " 在公路上运行....");
    }
}
```

解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可

#### 遵守原则

```java
package com.atguigu.principle.singleresponsibility;

public class SingleResponsibility2 {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		RoadVehicle roadVehicle = new RoadVehicle();
		roadVehicle.run("摩托车");
		roadVehicle.run("汽车");
		
		AirVehicle airVehicle = new AirVehicle();
		airVehicle.run("飞机");
	}
}

class RoadVehicle {
	public void run(String vehicle) {
		System.out.println(vehicle + "公路运行");
	}
}

class AirVehicle {
	public void run(String vehicle) {
		System.out.println(vehicle + "天空运行");
	}
}

class WaterVehicle {
	public void run(String vehicle) {
		System.out.println(vehicle + "水中运行");
	}
}
```

### 接口隔离原则

客户端不应该依赖它不需要的接口，即==一个类对另一个类的依赖应该建立在最小的接口上==



#### 违背原则

类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D

如果接口 Interface1 对于类 A 和类 C来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法

代码就会额外冗长

```java
interface Interface1 {
    void operation1();
    void operation2();
    void operation3();
    void operation4();
    void operation5();
}

class B implements Interface1 {
    @Override
    public void operation1() {
        System.out.println("B 实现了 operation1");
    }
    @Override
    public void operation2() {
        System.out.println("B 实现了 operation2");
    }
    @Override
    public void operation3() {
        System.out.println("B 实现了 operation3");
    }
    @Override
    public void operation4() {
        System.out.println("B 实现了 operation4");
    }
    @Override
    public void operation5() {
        System.out.println("B 实现了 operation5");
    }
}

class D implements Interface1 {
    @Override
    public void operation1() {
        System.out.println("D 实现了 operation1");
    }
    @Override
    public void operation2() {
        System.out.println("D 实现了 operation2");
    }
    @Override
    public void operation3() {
        System.out.println("D 实现了 operation3");
    }
    @Override
    public void operation4() {
        System.out.println("D 实现了 operation4");
    }
    @Override
    public void operation5() {
        System.out.println("D 实现了 operation5");
    }
}

class A { //A 类通过接口Interface1 依赖(使用) B类，但是只会用到1,2,3方法
    public void depend1(Interface1 i) {
        i.operation1();
    }
    public void depend2(Interface1 i) {
        i.operation2();
    }
    public void depend3(Interface1 i) {
        i.operation3();
    }
}

class C { //C 类通过接口Interface1 依赖(使用) D类，但是只会用到1,4,5方法
    public void depend1(Interface1 i) {
        i.operation1();
    }
    public void depend4(Interface1 i) {
        i.operation4();
    }
    public void depend5(Interface1 i) {
        i.operation5();
    }
}
```

类图简单但是过分冗余

<img src="./img/1.png" style="zoom: 80%;" />



#### 遵守原则

按隔离原则应当这样处理：
将接口 Interface1 拆分为独立的几个接口(这里我们拆分成 3 个接口)，类 A 和类 C 分别与他们需要的接口建立
依赖关系。

```java
package com.atguigu.principle.segregation.improve;

public class Segregation1 {
    public static void main(String[] args) {
        A a = new A();
        a.depend1(new B()); // A类通过接口去依赖B类
        a.depend2(new B());
        a.depend3(new B());
        
        C c = new C();
        c.depend1(new D()); // C类通过接口去依赖D类
        c.depend4(new D());
        c.depend5(new D());
    }
}

interface Interface1 {
    void operation1();
}

interface Interface2 {
    void operation2();
    void operation3();
}

interface Interface3 {
    void operation4();
    void operation5();
}

class B implements Interface1, Interface2 {
    @Override
    public void operation1() {
        System.out.println("B 实现了 operation1");
    }
    @Override
    public void operation2() {
        System.out.println("B 实现了 operation2");
    }
    @Override
    public void operation3() {
        System.out.println("B 实现了 operation3");
    }
}

class D implements Interface1, Interface3 {
    @Override
    public void operation1() {
        System.out.println("D 实现了 operation1");
    }
    @Override
    public void operation4() {
        System.out.println("D 实现了 operation4");
    }
    @Override
    public void operation5() {
        System.out.println("D 实现了 operation5");
    }
}

class A { // A 类通过接口Interface1,Interface2 依赖(使用) B类，但是只会用到1,2,3方法
    public void depend1(Interface1 i) {
        i.operation1();
    }
    public void depend2(Interface2 i) {
        i.operation2();
    }
    public void depend3(Interface2 i) {
        i.operation3();
    }
}

class C { // C 类通过接口Interface1,Interface3 依赖(使用) D类，但是只会用到1,4,5方法
    public void depend1(Interface1 i) {
        i.operation1();
    }
    public void depend4(Interface3 i) {
        i.operation4();
    }
    public void depend5(Interface3 i) {
        i.operation5();
    }
}
```

优化后的类图，B和D不必实现没用的接口方法，整体更加优雅

<img src="./img/2.png" style="zoom:75%;" />

### 依赖倒转原则

细节应该依赖抽象，中心思想是==面向接口编程==

依赖倒转原则是基于这样的设计理念:相对于细节的多变性,抽象的东西要稳定的多。以抽象为基础搭建的架
构比以细节为基础的架构要稳定的多。抽象指的是接口或抽象类，细节就是具体的实现类

使用接口或抽象类的目的是制定好规范,而不涉及任何具体的操作,把展现细节的任务交给他们的实现类去完
成

注意事项：

1. 低层模块尽量都要有抽象类或接口，程序稳定性更好
2. ==变量的声明类型尽量是抽象类或接口==， 这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展
   和优化
3. 继承时遵循里氏替换原则

#### 违背原则

email变量的类型太具体，不益于后续扩展

```java
class Email {
    public String getInfo() {
        return "电子邮件信息: hello,world";
    }
}

//完成Person接收消息的功能
//方式1分析
//1. 简单，比较容易想到
//2. 如果我们获取的对象是 微信，短信等等，则新增类，同时Perons也要增加相应的接收方法
//3. 解决思路：引入一个抽象的接口IReceiver, 表示接收者, 这样Person类与接口IReceiver发生依赖
//   因为Email, WeiXin 等等属于接收的范围，他们各自实现IReceiver 接口就ok, 这样我们就符号依赖倒转原则
class Person {
    public void receive(Email email) {
        System.out.println(email.getInfo());
    }
}
```

#### 遵守原则

面向接口，扩展起来就很方便优雅

```java
package com.atguigu.principle.inversion.improve;

public class DependecyInversion {
    public static void main(String[] args) {
        //客户端无需改变
        Person person = new Person();
        person.receive(new Email());
        person.receive(new WeiXin());
    }
}

//定义接口
interface IReceiver {
    public String getInfo();
}

class Email implements IReceiver {
    @Override
    public String getInfo() {
        return "电子邮件信息: hello,world";
    }
}

//增加微信
class WeiXin implements IReceiver {
    @Override
    public String getInfo() {
        return "微信信息: hello,ok";
    }
}

class Person {
    public void receive(IReceiver receiver ) {
        System.out.println(receiver.getInfo());
    }
}
```

#### 依赖关系传递的三种方式

##### 接口传递

不需要成员变量，直接通过方法参数把实现类传递过去

```java
interface IOpenAndClose {
    public void open(ITV tv);
}

interface ITV {
    public void play();
}

class OpenAndClose implements IOpenAndClose {
    @Override
    public void open(ITV tv) {
        tv.play();
    }
}

class ChangHong implements ITV {
    @Override
    public void play() {
        System.out.println("长虹电视机，打开");
    }
}
```



##### 构造方法传递

ITV的实现类作为成员变量，利用构造器初始化

```java
interface IOpenAndClose {
    public void open(); //抽象方法
}

interface ITV { //ITV接口
    public void play();
}

class OpenAndClose implements IOpenAndClose {
    public ITV tv; //成员
    
    public OpenAndClose(ITV tv) { //构造器
        this.tv = tv;
    }
    @Override
    public void open() {
        this.tv.play();
    }
}

class ChangHong implements ITV {
    @Override
    public void play() {
        System.out.println("长虹电视机，打开");
    }
}
```



##### setter 方式传递

ITV的实现类作为成员变量，利用setter初始化

```java
// 方式3 , 通过setter方法传递
interface IOpenAndClose {
    public void open(); // 抽象方法
    public void setTv(ITV tv);
}

interface ITV { // ITV接口
    public void play();
}

class OpenAndClose implements IOpenAndClose {
    private ITV tv;
    
    @Override
    public void setTv(ITV tv) {
        this.tv = tv;
    }
    @Override
    public void open() {
        this.tv.play();
    }
}

class ChangHong implements ITV {
    @Override
    public void play() {
        System.out.println("长虹电视机，打开");
    }
}
```



### 里氏替换原则

继承弊端：耦合性高

如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类。因为父类修改后，所有涉及到子类的功能都有可能产生故障

里氏替换原则：==在子类中尽量不要重写父类的方法==

里氏替换原则告诉我们，继承实际上让两个类耦合性增强了。可以通过聚合、组合、依赖来解决问题

#### 违背原则

```java
class A {
    public int func1(int num1, int num2) {
        return num1 - num2;
    }
}

class B extends A {
    //这里，重写了A类的方法, 可能是无意识
    @Override
    public int func1(int a, int b) {
        return a + b;
    }
    
    public int func2(int a, int b) {
        return func1(a, b) + 9;
    }
}
```



#### 遵守原则

将公共的方法和成员提取成一个基类或者接口，从而实现子类之间的解耦合

如果不可避免互相引用，可以通过定义类对象作为私有成员，也就是组合的方式来实现

```java
//创建一个更加基础的基类
abstract class Base {
    //把更加基础的方法和成员写到Base类
    public abstract int func1(int num1, int num2);
}

class A extends Base {
    @Override
    public int func1(int num1, int num2) {
        return num1 - num2;
    }
}

class B extends Base {
    //如果B需要使用A类的方法,使用组合关系
    private A a = new A();
    
    @Override
    public int func1(int a, int b) {
        return a + b;
    }
    
    public int func2(int a, int b) {
        return func1(a, b) + 9;
    }
    
    //我们仍然想使用A的方法
    public int func3(int a, int b) {
        return this.a.func1(a, b);
    }
}
```



### 开闭原则

模块和函数应该==对扩展开放==(对提供方)，==对修改关闭==(对使用方)

当软件需要变化时，==尽量通过扩展软件实体的行为来实现变化==，而不是通过修改已有的代码来实现变化



#### 违背原则

如果增加一个额外的图形类，底层的用户类GraphicEditor代码需要对应发生较大的变动，不易于扩展

```java
//这是一个用于绘图的类 [使用方]
class GraphicEditor {
    //接收Shape对象，然后根据type，来绘制不同的图形
    public void drawShape(Shape s) {
        if (s.m_type == 1)
            drawRectangle(s);
        else if (s.m_type == 2)
            drawCircle(s);
        else if (s.m_type == 3)
            drawTriangle(s);
    }
    
    //绘制矩形
    public void drawRectangle(Shape r) {
        System.out.println(" 绘制矩形 ");
    }
    
    //绘制圆形
    public void drawCircle(Shape r) {
        System.out.println(" 绘制圆形 ");
    }
    
    //绘制三角形
    public void drawTriangle(Shape r) {
        System.out.println(" 绘制三角形 ");
    }
}

//Shape类，基类
class Shape {
    int m_type;
}

class Rectangle extends Shape {
    Rectangle() {
        super.m_type = 1;
    }
}

class Circle extends Shape {
    Circle() {
        super.m_type = 2;
    }
}

//新增画三角形
class Triangle extends Shape {
    Triangle() {
        super.m_type = 3;
    }
}
```



#### 遵守原则

把创建 Shape 类做成抽象类，并提供一个抽象的 draw 方法让子类去实现即可

这样我们有新的图形种类时，只需要让新的图形类继承 Shape，实现 draw 方法即可，使用方的代码就不需要修改

代码易于扩展，而且对于用户不需要修改，也就是开闭原则

```java
//这是一个用于绘图的类 [使用方]
class GraphicEditor {
    public void drawShape(Shape s) {
        s.draw();
    }
}

abstract class Shape {
    int m_type;
    public abstract void draw();
}

class Rectangle extends Shape {
    Rectangle() {
        super.m_type = 1;
    }
    @Override
    public void draw() {
        System.out.println(" 绘制矩形 ");
    }
}

class Circle extends Shape {
    Circle() {
        super.m_type = 2;
    }
    @Override
    public void draw() {
        System.out.println(" 绘制圆形 ");
    }
}

class Triangle extends Shape {
    Triangle() {
        super.m_type = 3;
    }
    @Override
    public void draw() {
        System.out.println(" 绘制三角形 ");
    }
}

//新增一个图形
class OtherGraphic extends Shape {
    OtherGraphic() {
        super.m_type = 4;
    }
    @Override
    public void draw() {
        System.out.println(" 绘制其它图形 ");
    }
}
```



### 迪米特原则

迪米特法则(Demeter Principle)又叫最少知道原则，即一个类==对自己依赖的类知道的越少越好==。

对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息

迪米特法则还有个更简单的定义：==只与直接的朋友通信==

直接的朋友：我们称出现**<u>成员变量、方法参数、方法返回值</u>**中的类为直接的朋友；而出现在局部变量中的类不是直接的朋友。

陌生的类最好不要以局部变量的形式出现在类的内部

#### 违背原则

```java
//学院
class CollegeManager {
    public List<CollegeEmployee> getAllEmployee() {
        List<CollegeEmployee> list = new ArrayList<CollegeEmployee>();
        for (int i = 0; i < 10; i++) { //这里我们增加了10个员工到 list
            CollegeEmployee emp = new CollegeEmployee();
            emp.setId("学院员工id= " + i);
            list.add(emp);
        }
        return list;
    }
}

//学校
//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager
//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了迪米特法则
class SchoolManager {
    public List<Employee> getAllEmployee() {
        List<Employee> list = new ArrayList<Employee>();
        for (int i = 0; i < 5; i++) {
            Employee emp = new Employee();
            emp.setId("学校总部员工id= " + i);
            list.add(emp);
        }
        return list;
    }
    
    //该方法完成输出学校总部和学院员工信息(id)
    void printAllEmployee(CollegeManager sub) {
        //分析问题
        //1. 这里的 CollegeEmployee 不是  SchoolManager的直接朋友
        //2. CollegeEmployee 是以局部变量方式出现在 SchoolManager
        //3. 违反了迪米特法则
        
        //获取到学院员工
        List<CollegeEmployee> list1 = sub.getAllEmployee();
        System.out.println("------------学院员工------------");
        for (CollegeEmployee e : list1) {
            System.out.println(e.getId());
        }
        //获取到学校总部员工
        List<Employee> list2 = this.getAllEmployee();
        System.out.println("------------学校总部员工------------");
        for (Employee e : list2) {
            System.out.println(e.getId());
        }
    }
}
```

加大封装的力度，能不对外暴露的成员就不要暴露出去，解耦合更优雅

#### 遵守原则

```java
//学院
class CollegeManager {
    public List<CollegeEmployee> getAllEmployee() {
        List<CollegeEmployee> list = new ArrayList<CollegeEmployee>();
        for (int i = 0; i < 10; i++) {
            CollegeEmployee emp = new CollegeEmployee();
            emp.setId("学院员工id= " + i);
            list.add(emp);
        }
        return list;
    }
    
    public void printEmployee() {
        //CollegeEmployee实现封装，不对外暴露
        List<CollegeEmployee> list1 = getAllEmployee();
        System.out.println("------------学院员工------------");
        for (CollegeEmployee e : list1) {
            System.out.println(e.getId());
        }
    }
}

//学校
//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager
//优化后，代码中不出现 CollegeEmployee 这样的陌生类
class SchoolManager {
    public List<Employee> getAllEmployee() {
        List<Employee> list = new ArrayList<Employee>();
        
        for (int i = 0; i < 5; i++) {
            Employee emp = new Employee();
            emp.setId("学校总部员工id= " + i);
            list.add(emp);
        }
        return list;
    }
    
    void printAllEmployee(CollegeManager sub) {
        //1. 将输出学院的员工方法，封装到CollegeManager，对外暴露一个方法，简洁搞定打印功能
        sub.printEmployee();
        
        List<Employee> list2 = this.getAllEmployee();
        System.out.println("------------学校总部员工------------");
        for (Employee e : list2) {
            System.out.println(e.getId());
        }
    }
}
```



### 合成复用原则

尽量使用合成/聚合的方式，而不是使用继承（耦合性太强了）

==尽量has A，而不是is A==。这样耦合度更低

三种has A的方式：

1、依赖dependency，传参

2、聚合aggregation，setter

3、组合composite，初始化构造

![](./img/3.png)



### 设计原则核心思想

- 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起

- 针对接口编程，而不是针对实现编程

- 为了交互对象之间的松耦合设计而努力

  

## UML 类图

Unified modeling language UML (统一建模语言)

是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果

UML 本身是==一套符号的规定==，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系

<img src="./img/4.png" style="zoom:75%;" />

类之间的关系：依赖、泛化(继承)、实现、关联、聚合与组合

- 依赖关系(Dependence)：只要是在类中用到了对方，那么他们之间就存在依赖关系

- 泛化关系(generalization)：泛化关系实际上就是继承关系，他是依赖关系的特例

- 实现关系(Implementation)：实现关系实际上就是 A 类实现 B 接口，他是依赖关系的特例

- 关联关系(Association)：类之间的联系

- 聚合关系(Aggregation)：表示的是整体和部分的关系，==整体与部分可以分开==。聚合关系是关联关系的特例，所以他具有关联的导航性与多重性。如一台电脑由键盘(keyboard)、显示器(monitor)、鼠标等组成；组成电脑的各个配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示

- 组合关系(Composition)：也是整体与部分的关系，但是==整体与部分不可以分开==。Person 与 IDCard、 Head： Head 和 Person 就是 组合；IDCard 和 Person 就是聚合

  

## 23种设计模式

设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是某类问题的通用解决方案，设计模式(Design pattern)代表了最佳的实践

设计模式提高软件的维护性、通用性和扩展性、并降低软件的复杂度

设计模式分为三种类型，共 23 种：

- 创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式
- 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式
- 行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式(Interpreter 模式)、状态模式、策略模式、职责链模式(责任链模式)

### 单例设计模式

所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法(静态方法)。

#### 1、饿汉式(静态常量)

```java
class Singleton {
    
    //1. 构造器私有化, 外部不能new
    private Singleton() {
    
    }
    
    //2.本类内部创建对象实例
    private final static Singleton instance = new Singleton();
    
    //3. 提供一个公有的静态方法，返回实例对象
    public static Singleton getInstance() {
        return instance;
    }
    
}
```

优点：这种写法比较简单，就是在类装载的时候就完成实例化，避免了线程同步问题。

缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费

#### 2、饿汉式(静态代码块)

```java
class Singleton {
    
    //1. 构造器私有化, 外部能new
    private Singleton() {
    
    }
    
    //2.本类内部创建对象实例
    private  static Singleton instance;
    
    static { // 在静态代码块中，创建单例对象
        instance = new Singleton();
    }
    
    //3. 提供一个公有的静态方法，返回实例对象
    public static Singleton getInstance() {
        return instance;
    }
    
}
```

将类实例化的过程放在了静态代码块中，也是在类装载的时候就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。

#### 3、懒汉式(线程不安全) - 不推荐

```java
class Singleton {
    private static Singleton instance;
    
    private Singleton() {}
    
    //提供一个静态的公有方法，当使用到该方法时，才去创建 instance
    //即懒汉式
    public static Singleton getInstance() {
        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

起到了 Lazy Loading 的效果，但是只能在单线程下使用。在实际开发中不要使用这种方式

#### 4、懒汉式(线程安全,同步方法) - 不推荐

```java
class Singleton {
    private static Singleton instance;
    
    private Singleton() {}
    
    //提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题
    //即懒汉式
    public static synchronized Singleton getInstance() {
        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

解决了线程安全问题，方法进行同步效率太低

#### 5、双重检查

```java
class Singleton {
    private static volatile Singleton instance;
    
    private Singleton() {}
    
    //提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题
    //同时保证了效率, 推荐使用
    public static Singleton getInstance() {
        if(instance == null) {
            synchronized (Singleton.class) {
                if(instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

Double-Check 概念是多线程开发中常使用到的，同步块在if判断中，加载实例后会直接跳过，避免反复进行方法同步

线程安全、延迟加载、效率较高

#### 6、静态内部类

```java
class Singleton {
    private static volatile Singleton instance;
    
    //构造器私有化
    private Singleton() {}
    
    //写一个静态内部类,该类中有一个静态属性 Singleton
    private static class SingletonInstance {
        private static final Singleton INSTANCE = new Singleton();
    }
    
    //提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE
    public static Singleton getInstance() {
        return SingletonInstance.INSTANCE;
    }
}
```

静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化

类的静态属性只会在第一次加载类的时候初始化，所以在这里JVM 帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的

避免了线程不安全，利用静态内部类特点实现延迟加载，效率高

#### 7、枚举

```java
public class SingletonTest08 {
    public static void main(String[] args) {
        Singleton instance = Singleton.INSTANCE;
        Singleton instance2 = Singleton.INSTANCE;
        System.out.println(instance == instance2);
        
        System.out.println(instance.hashCode());
        System.out.println(instance2.hashCode());
        
        instance.sayOK();
    }
}

//使用枚举，可以实现单例, 推荐
enum Singleton {
    INSTANCE; //属性
    public void sayOK() {
        System.out.println("ok~");
    }
}
```

不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象

































